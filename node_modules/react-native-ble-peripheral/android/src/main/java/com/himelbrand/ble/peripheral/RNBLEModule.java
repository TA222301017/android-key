package com.himelbrand.ble.peripheral;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothGatt;
import android.bluetooth.BluetoothGattCharacteristic;
import android.bluetooth.BluetoothGattDescriptor;
import android.bluetooth.BluetoothGattServer;
import android.bluetooth.BluetoothGattServerCallback;
import android.bluetooth.BluetoothGattService;
import android.bluetooth.BluetoothManager;
import android.bluetooth.le.AdvertiseCallback;
import android.bluetooth.le.AdvertiseData;
import android.bluetooth.le.AdvertiseSettings;
import android.bluetooth.le.BluetoothLeAdvertiser;
import android.bluetooth.le.BluetoothLeScanner;
import android.bluetooth.le.ScanCallback;
import android.bluetooth.le.ScanFilter;
import android.bluetooth.le.ScanResult;
import android.bluetooth.le.ScanSettings;
import android.content.Context;
import android.os.Bundle;
import android.os.Handler;
import android.os.ParcelUuid;
import androidx.appcompat.app.AppCompatActivity;
import android.text.TextUtils;
import android.util.Log;

import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import android.content.Intent;
import android.net.Uri;
import android.widget.Toast;

import com.facebook.react.bridge.NativeModule;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableType;
import com.facebook.react.common.MapBuilder;
import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.bridge.WritableNativeArray;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
// import java.util.Base64;

/**
 * {@link NativeModule} that allows JS to open the default browser
 * for an url.
 */
public class RNBLEModule extends ReactContextBaseJavaModule {

    ReactApplicationContext reactContext;
    HashMap<String, BluetoothGattService> servicesMap;
    HashSet<BluetoothDevice> mBluetoothDevices;
    BluetoothManager mBluetoothManager;
    BluetoothAdapter mBluetoothAdapter;
    BluetoothGattServer mGattServer;
    BluetoothLeAdvertiser advertiser;
    String name;
    boolean advertising;
    private Context context;
    HashMap<String, byte[]> charValMap;
    HashMap<String, BluetoothGattCharacteristic> characteristicsMap;
    AdvertiseCallback advertisingCallback;
    AdvertiseData advData;

    public RNBLEModule(ReactApplicationContext reactContext) {
        super(reactContext);
        this.reactContext = reactContext;
        this.context = reactContext;
        this.servicesMap = new HashMap<String, BluetoothGattService>();
        this.advertising = false;
        this.name = "RN_BLE";
        this.charValMap = new HashMap<String, byte[]>();
        this.characteristicsMap = new HashMap<String, BluetoothGattCharacteristic>();
    }

    public static byte[] integerArrayToByteArray(Integer[] integers) {
        ByteBuffer buffer = ByteBuffer.allocate(integers.length * 4);
        for (int i : integers) {
            buffer.putInt(i);
        }
        return buffer.array();
    }

    public static Integer[] byteArrayToIntegerArray(byte[] bytes) {
        if (bytes.length % 4 != 0) {
            throw new IllegalArgumentException("Array byte tidak valid");
        }

        Integer[] integers = new Integer[bytes.length / 4];
        ByteBuffer buffer = ByteBuffer.wrap(bytes);
        for (int i = 0; i < integers.length; i++) {
            integers[i] = buffer.getInt();
        }
        return integers;
    }

    public static ReadableArray integerArrayToReadableArray(Integer[] integers) {
        WritableArray writableArray = new WritableNativeArray();
        for (int i : integers) {
            writableArray.pushInt(i);
        }
        return writableArray;
    }

    // public static ReadableArray byteArrayToReadableArray(byte[] bytes) {
    // WritableArray writableArray = new WritableNativeArray();
    // for (byte b : bytes) {
    // writableArray.pushInt(b);
    // }
    // return writableArray;
    // }
    public static byte[] aesDecrypt(byte[] ciphertext) {
        try {

            String key = "1111111111111111";
            String iv = "1111111111111111";

            // byte[] encryptedBytes = Base64.getDecoder().decode(encryptedText);

            SecretKey secretKey = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), "AES");
            IvParameterSpec ivSpec = new IvParameterSpec(iv.getBytes(StandardCharsets.UTF_8));

            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);
            byte[] decryptedBytes = cipher.doFinal(ciphertext);

            String decryptedText = new String(decryptedBytes, StandardCharsets.UTF_8);
            // System.out.println("Decrypted Text: " + decryptedText);
            return decryptedBytes;
        } catch (Exception e) {
            byte[] d = { (byte) 0x00 };
            return d;
        }
        // String encryptedText = "hKt2Buh/3aF18XZ9bT9tfA==";
    }

    public static ReadableArray byteArrayToReadableArray(byte[] bytes) {
        WritableArray writableArray = Arguments.createArray();
        for (byte b : bytes) {
            writableArray.pushInt(b & 0xFF);
        }
        return writableArray;
    }

    public static Integer[] readableArrayToIntegerArray(ReadableArray readableArray) {
        Integer[] integers = new Integer[readableArray.size()];
        for (int i = 0; i < readableArray.size(); i++) {
            if (readableArray.getType(i) == ReadableType.Number) {
                integers[i] = readableArray.getInt(i);
            } else {
                // Menggunakan nilai default jika tipe tidak valid
                integers[i] = 0;
            }
        }
        return integers;
    }

    public static byte[] readableArrayToByteArray(ReadableArray readableArray) {
        byte[] bytes = new byte[readableArray.size()];
        for (int i = 0; i < readableArray.size(); i++) {
            if (readableArray.getType(i) == ReadableType.Number) {
                bytes[i] = (byte) readableArray.getInt(i);
            } else {
                // Menggunakan nilai default jika tipe tidak valid
                bytes[i] = 0;
            }
        }
        return bytes;
    }

    @Override
    public String getName() {
        return "BLEPeripheral";
    }

    @ReactMethod
    public void setName(String name) {
        this.name = name;
        Log.i("RNBLEModule", "name set to " + name);
    }

    @ReactMethod
    public void addService(String uuid, Boolean primary) {
        UUID SERVICE_UUID = UUID.fromString(uuid);
        int type = primary ? BluetoothGattService.SERVICE_TYPE_PRIMARY : BluetoothGattService.SERVICE_TYPE_SECONDARY;
        BluetoothGattService tempService = new BluetoothGattService(SERVICE_UUID, type);
        if (!this.servicesMap.containsKey(uuid))
            this.servicesMap.put(uuid, tempService);
    }

    @ReactMethod
    public void addCharacteristicToService(String serviceUUID, String uuid, Integer permissions, Integer properties) {
        UUID CHAR_UUID = UUID.fromString(uuid);
        BluetoothGattCharacteristic tempChar = new BluetoothGattCharacteristic(CHAR_UUID, properties, permissions);
        this.servicesMap.get(serviceUUID).addCharacteristic(tempChar);
        this.characteristicsMap.put(uuid, tempChar);
    }

    private final BluetoothGattServerCallback mGattServerCallback = new BluetoothGattServerCallback() {
        @Override
        public void onConnectionStateChange(BluetoothDevice device, final int status, int newState) {
            super.onConnectionStateChange(device, status, newState);
            if (status == BluetoothGatt.GATT_SUCCESS) {
                if (newState == BluetoothGatt.STATE_CONNECTED) {
                    mBluetoothDevices.add(device);
                } else if (newState == BluetoothGatt.STATE_DISCONNECTED) {
                    mBluetoothDevices.remove(device);
                }
            } else {
                mBluetoothDevices.remove(device);
            }
        }

        @Override
        public void onCharacteristicReadRequest(BluetoothDevice device, int requestId, int offset,
                BluetoothGattCharacteristic characteristic) {
            super.onCharacteristicReadRequest(device, requestId, offset, characteristic);
            if (offset != 0) {
                mGattServer.sendResponse(device, requestId, BluetoothGatt.GATT_INVALID_OFFSET, offset,
                        /* value (optional) */ null);
                return;
            }
            mGattServer.sendResponse(device, requestId, BluetoothGatt.GATT_SUCCESS,
                    offset, characteristic.getValue());
        }

        @Override
        public void onNotificationSent(BluetoothDevice device, int status) {
            super.onNotificationSent(device, status);
        }

        @Override
        public void onCharacteristicWriteRequest(BluetoothDevice device, int requestId,
                BluetoothGattCharacteristic characteristic, boolean preparedWrite, boolean responseNeeded,
                int offset, byte[] value) {
            super.onCharacteristicWriteRequest(device, requestId, characteristic, preparedWrite,
                    responseNeeded, offset, value);
            characteristic.setValue(value);
            characteristicsMap.get("19b10010-e8f2-537e-4f6c-d104768a1217").setValue(aesDecrypt(value));
            // writeCharacteristic("19b10010-e8f2-537e-4f6c-d104768a1215",
            // aesDecrypt(value));
            WritableMap map = Arguments.createMap();
            WritableArray data = Arguments.createArray();
            for (byte b : value) {
                data.pushInt((int) b);
            }
            charValMap.put(characteristic.getUuid().toString(), value);
            map.putArray("data", data);
            map.putString("device", device.toString());
            if (responseNeeded) {
                mGattServer.sendResponse(device, requestId, BluetoothGatt.GATT_SUCCESS, offset, value);
            }
        }
    };

    @ReactMethod
    public void readCharacteristic(String charUUIDString, final Promise promise) {

        // byte[] manData = { (byte) 0x53, (byte) 0x41, (byte) 0x43, (byte) 0x5F, (byte)
        // 0x30,
        // (byte) 0x30, (byte) 0x30, (byte) 0x30, (byte) 0x30 };
        // BluetoothGattService s =
        // this.servicesMap.get('19b10010-e8f2-537e-4f6c-d104768a1213');
        // return
        byte[] manData = this.characteristicsMap.get(charUUIDString).getValue();
        if (manData == null) {
            manData = new byte[1];
            manData[0] = 0;
        }
        promise.resolve(byteArrayToReadableArray(manData));
    }

    @ReactMethod
    public void writeCharacteristic(String charUUIDString, ReadableArray value) {
        byte[] valueb = readableArrayToByteArray(value);
        this.characteristicsMap.get(charUUIDString).setValue(valueb);
    }

    @ReactMethod
    public void start(Boolean connectable, final Promise promise) {
        String label;
        mBluetoothManager = (BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE);
        mBluetoothAdapter = mBluetoothManager.getAdapter();
        mBluetoothAdapter.setName(this.name);
        // Ensures Bluetooth is available on the device and it is enabled. If not,
        // displays a dialog requesting user permission to enable Bluetooth.

        mBluetoothDevices = new HashSet<>();
        mGattServer = mBluetoothManager.openGattServer(reactContext, mGattServerCallback);
        for (BluetoothGattService service : this.servicesMap.values()) {
            mGattServer.addService(service);
        }
        advertiser = mBluetoothAdapter.getBluetoothLeAdvertiser();
        AdvertiseSettings settings = new AdvertiseSettings.Builder()
                .setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY)
                .setTxPowerLevel(AdvertiseSettings.ADVERTISE_TX_POWER_HIGH)
                .setConnectable(true)
                .build();

        this.advertisingCallback = new AdvertiseCallback() {
            @Override
            public void onStartSuccess(AdvertiseSettings settingsInEffect) {
                super.onStartSuccess(settingsInEffect);
                advertising = true;
                promise.resolve("Success, Started Advertising");
            }

            @Override
            public void onStartFailure(int errorCode) {
                advertising = false;
                Log.e("RNBLEModule", "Advertising onStartFailure: " + errorCode);
                promise.reject("Advertising onStartFailure: " + errorCode);
                super.onStartFailure(errorCode);
            }
        };

        AdvertiseData.Builder dataBuilder;
        if (connectable) {
            // Log.i("RNBLEModule", "KONEK");
            // AAFE5341435F30303031310000000000
            label = "Konek";
            byte[] manData = { (byte) 0x53, (byte) 0x41, (byte) 0x43, (byte) 0x5F, (byte) 0x30,
                    (byte) 0x30, (byte) 0x30, (byte) 0x31, (byte) 0x31 };
            dataBuilder = new AdvertiseData.Builder()
                    .setIncludeDeviceName(false)
                    .addServiceData(ParcelUuid.fromString("0000feaa-0000-1000-8000-00805f9b34fb"),
                            manData);

        } else {
            // Log.i("RNBLEModule", "DISKONEK");
            label = "Diskonek";
            byte[] manData = { (byte) 0x53, (byte) 0x41, (byte) 0x43, (byte) 0x5F, (byte) 0x30,
                    (byte) 0x30, (byte) 0x30, (byte) 0x31, (byte) 0x30 };
            dataBuilder = new AdvertiseData.Builder()
                    .setIncludeDeviceName(false)
                    .addServiceData(ParcelUuid.fromString("0000feaa-0000-1000-8000-00805f9b34fb"),
                            manData);
        }

        // for (BluetoothGattService service : this.servicesMap.values()) {
        // dataBuilder.addServiceUuid(new ParcelUuid(service.getUuid()));
        // }
        advData = dataBuilder.build();
        Log.i("RNBLEModule", advData.toString());

        advertiser.startAdvertising(settings, advData, this.advertisingCallback);

        promise.resolve(label);
    }

    @ReactMethod
    public void stop(final Promise promise) {
        if (mGattServer != null) {
            mGattServer.close();
        }
        // if (mBluetoothAdapter != null && mBluetoothAdapter.isEnabled() && advertiser
        // != null) {
        // // If stopAdvertising() gets called before close() a null
        // // pointer exception is raised.
        // advertiser.stopAdvertising(this.advertisingCallback);
        // }
        advertiser.stopAdvertising(this.advertisingCallback);

        promise.resolve("stopped");
    }

    @ReactMethod
    public void sendNotificationToDevices(String serviceUUID, String charUUID, ReadableArray message) {
        byte[] decoded = new byte[message.size()];
        for (int i = 0; i < message.size(); i++) {
            decoded[i] = new Integer(message.getInt(i)).byteValue();
        }
        BluetoothGattCharacteristic characteristic = servicesMap.get(serviceUUID)
                .getCharacteristic(UUID.fromString(charUUID));
        characteristic.setValue(decoded);
        boolean indicate = (characteristic.getProperties()
                & BluetoothGattCharacteristic.PROPERTY_INDICATE) == BluetoothGattCharacteristic.PROPERTY_INDICATE;
        for (BluetoothDevice device : mBluetoothDevices) {
            // true for indication (acknowledge) and false for notification
            // (un-acknowledge).
            mGattServer.notifyCharacteristicChanged(device, characteristic, indicate);
        }
    }

    @ReactMethod
    public void isAdvertising(Promise promise) {
        promise.resolve(this.advertising);
    }

}
